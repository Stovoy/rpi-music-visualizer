use std::f32;
use std::os::raw::c_void;

use gfx;
use gfx::gl;

// For use with DotStar RGB LED Disk - 240mm
// https://adafruit.com/product/2477
static RINGS: [[u8; 2]; 10] = [
    [254, 254],
    [248, 253],
    [236, 247],
    [216, 235],
    [192, 215],
    [164, 191],
    [132, 163],
    [92, 131],
    [48, 91],
    [0, 47],
];

pub const NUM_PIXELS: usize = 255;
// Distance units based on normalized point space of [-1, 1].
pub const DISTANCE_BETWEEN_RINGS: f32 = 0.1;
pub const PIXEL_RADIUS: f32 = 0.035;

pub struct LedDiskMapper {
    program_id: u32,
}

impl LedDiskMapper {
    pub fn new() -> LedDiskMapper {
        LedDiskMapper { program_id: 0 }
    }

    // Convert from a texture image into a map of tightly packed RGB values mapping from
    // pixel 0 to pixel 255. This mapping is generated by averaging colors near each pixel
    // from the texture. This is done using 5 samples - center of pixel, and the four corners
    // surrounded it (based on PIXEL_RADIUS).
    pub fn map_from_texture(&self, gl: &gfx::gl::Gl, _texture: u32) -> [(u8, u8, u8); NUM_PIXELS] {
        unsafe {
            gl_try!(gl; gl.UseProgram(self.program_id));

            let width = 1024;
            let height = 1024;
            let mut pixels = vec![0 as u8; 3 * width * height];

            gl_try!(gl; gl.ReadPixels(
                0, 0,
                width as i32, height as i32,
                gl::RGB, gl::UNSIGNED_BYTE,
                pixels.as_mut_ptr() as *mut c_void));

            let get_index = |x: f32, y: f32| -> (usize, usize) {
                (self.map_normalized_value(x, (width - 1) as f32) as usize,
                 self.map_normalized_value(y, (height - 1) as f32) as usize)
            };

            let get_rgb = |x_index: usize, y_index: usize| -> (u8, u8, u8) {
                let pixel_index = x_index * 3 + y_index * width * 3;
                return (
                    pixels[pixel_index],
                    pixels[pixel_index + 1],
                    pixels[pixel_index + 2],
                );
            };

            let mut mapped_led_pixel_colors = [(0, 0, 0); NUM_PIXELS];
            for pixel_index in 0..NUM_PIXELS {
                let (x, y) = self.get_pixel_normalized_position(pixel_index as u8);

                let normalized_sample_positions = [
                    (x, y),
                    (x - PIXEL_RADIUS, y - PIXEL_RADIUS),
                    (x - PIXEL_RADIUS, y + PIXEL_RADIUS),
                    (x + PIXEL_RADIUS, y - PIXEL_RADIUS),
                    (x + PIXEL_RADIUS, y + PIXEL_RADIUS),
                ];

                let (mut r_avg, mut g_avg, mut b_avg) = (0, 0, 0);
                for &(x, y) in normalized_sample_positions.iter() {
                    let (x_index, y_index) = get_index(x, y);
                    let (r, g, b) = get_rgb(x_index, y_index);
                    r_avg += r / normalized_sample_positions.len() as u8;
                    g_avg += g / normalized_sample_positions.len() as u8;
                    b_avg += b / normalized_sample_positions.len() as u8;
                }

                mapped_led_pixel_colors[pixel_index] = (r_avg, g_avg, b_avg);
            }

            mapped_led_pixel_colors
        }
    }

    // Given a pixel from 0..255, return it's (x, y) position as a tuple of two floats
    // in the normalized point space, [-1, 1], [-1..1].
    pub fn get_pixel_normalized_position(&self, pixel: u8) -> (f32, f32) {
        let ring_index = self.get_pixel_ring_index(pixel);
        let start_index = RINGS[ring_index as usize][0];
        let end_index = RINGS[ring_index as usize][1];
        let radians_between_pixels = 2.0 * f32::consts::PI / (end_index - start_index + 1) as f32;
        let angle = (pixel - start_index) as f32 * radians_between_pixels;
        let radius = ring_index as f32 * DISTANCE_BETWEEN_RINGS;

        (radius * f32::cos(angle), radius * f32::sin(angle))
    }

    // Get the ring index for given pixel.
    pub fn get_pixel_ring_index(&self, pixel: u8) -> u8 {
        for (i, ring) in RINGS.iter().enumerate() {
            if pixel >= ring[0] && pixel <= ring[1] {
                return i as u8;
            }
        }

        0
    }

    // Map a normalized float value from [-1, 1] to [0, magnitude].
    pub fn map_normalized_value(&self, value: f32, magnitude: f32) -> f32 {
        let clamped_value = f32::min(f32::max(value, -1.0), 1.0);
        (clamped_value + 1.0) / 2.0 * magnitude
    }
}
